#!/bin/bash

##
##         //\  //\  //\  //\  //\  //\  //\
##        //  \//  \//  \//  \//  \//  \//  \
##       //    _   _   _   _   _   _   _     \
##      //    / \ / \ / \ / \ / \ / \ / \     \
##     // Ⓐ  ( E ) X ) P ) E ) R ) M ) S )  Ⓐ  \
##    //  __  \_/ \_/ \_/ \_/ \_/ \_/ \_/   __  \
##   // //  \                             //  \  \
##  // //    \  //\  //\  //\  //\  //\  //    \  \
##  \_//      \//  \//  \//  \//  \//  \//      \_//
##
##                 version 0.1 - 2012
##

##=================================================================================================================================
##
##         FILE: experms
##
##        USAGE: experms [ start | stop | restart | stat | disable | enable | (log|stdout) | (err|stderr) | restore | help ]
##
##  DESCRIPTION: Runs as daemon and monitors file-changes happened in the directory set in experms.conf.
##               If changes happened, it adjusts the file-permissions and ownership/group.
##               Further it is able to restore all the ownerships and permissions of all files based on the config-file.
##
##       CONFIG: experms.conf
##
## REQUIREMENTS: inotify-tools
##
##         BUGS: When logging sometimes entries showing up double. This happens if they are written at the same time.
##               The random delay for writing an entry prevents this mostly.
##
##        NOTES: Experms uses inotifywait to monitor the directories.
##               Inotifywait allows only a limited number of directories to watch per user. Per default this is set to 8192.
##               You can increase this number by writing to /proc/sys/fs/inotify/max_user_watches.
##               You can check the number of directories recursively with:
##               find /your/directory/ -type d | wc -l
##
##       AUTHOR: fabio@dynamix-tontechnik.ch
##
##      VERSION: 0.1
##
##      LICENCE: GNU GPL v3.0 or later.
##               http://www.gnu.org/licenses/gpl-3.0.txt
##               Experms comes with absolutely no warranty!
##               
##      COPYING: Experms is free software: you can redistribute it and/or modify
##               it under the terms of the GNU General Public License as published by
##               the Free Software Foundation, either version 3 of the License, or
##               (at your option) any later version.
##           
##               Experms is distributed in the hope that it will be useful,
##               but WITHOUT ANY WARRANTY; without even the implied warranty of
##               MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##               GNU General Public License for more details.
##           
##               You should have received a copy of the GNU General Public License
##               along with Experms.  If not, see <http://www.gnu.org/licenses/>.
##
##      CREATED: 2012
##
##=================================================================================================================================


##=== FUNCTION ====================================================================================================
##        NAME: payload
## DESCRIPTION: This function contains all the code that we want to run as daemon.
##=================================================================================================================
function payload() {
    ##=== FUNCTION ====================================================================================================
    ##        NAME: func_action
    ## DESCRIPTION: This function does the action and logs it, if requested in the config-file.
    ## PARAMETER 1: Owner
    ## PARAMETER 2: Group
    ## PARAMETER 3: Octal permissions for directories
    ## PARAMETER 4: Octal permissions for files
    ## PARAMETER 5: Doitreally (octal)
    ##=================================================================================================================
    func_action() {
        own="$1"
        grp="$2"
        chmodoktd="$3"
        chmodoktf="$4"
        doitreally="$5"
        # Check if file still exists
        if ! [ -e "$FILE" ]
        then
            exit 0
        fi
        # The Action starts here.
        # Check if owner or group has to be changed.
        if [ "$doitreally" -eq 1 ] || [ "$doitreally" -eq 3 ] || [ "$doitreally" -eq 5 ] || [ "$doitreally" -eq 7 ]
        then
            # Check if group is already set and set it if necessary
            checkdouble=($(ls -la "$FILE"))
            if stat -c%G "$FILE" | egrep -q "^$grp$"
            then
                ischanged=0
            else
                chown "$own":"$grp" "$FILE"
                # If it is not possible to extecute the command, abort with an error-message.
                if [ $? -ne 0 ]; then
                    echo "chown
Based on your settings in the configuration-file you need to run experms with root-permissions.
Experms will abort now!" >&2
                $0 stop
                exit 1
                fi
                ischanged=1
            fi
        fi
        if [ "$doitreally" -eq 2 ] || [ "$doitreally" -eq 3 ] || [ "$doitreally" -eq 6 ] || [ "$doitreally" -eq 7 ]
        then
            # Check if permissions are already set for directories and set them if necessary
            if [ -d "$FILE" ]
            then
                if stat -c%a "$FILE" | egrep -vq "^$chmodoktd"
                then
                    chmod "$chmodoktd" "$FILE"
                    # Check if permissions are already set for directories and set them if necessary
                    if [ $? -ne 0 ]; then
                        echo "chmod
Based on your settings in the configuration-file you need to be the owner of all the monitored files.
Experms will abort now!" >&2
                    $0 stop
                    exit 1
                    fi
                    ischanged=1
                fi
            fi
        fi
        if [ "$doitreally" -eq 4 ] || [ "$doitreally" -eq 5 ] || [ "$doitreally" -eq 6 ] || [ "$doitreally" -eq 7 ]
        then
            # Check if permissions are already set for files and set them if necessary
            if [ -f "$FILE" ]
            then
                if stat -c%a "$FILE" | egrep -vq "^$chmodoktf"
                then
                    chmod "$chmodoktf" "$FILE"
                    # Check if permissions are already set for directories and set them if necessary
                    if [ $? -ne 0 ]; then
                        echo "chmod
Based on your settings in the configuration-file you need to be the owner of all the monitored files.
Experms will abort now!" >&2
                    $0 stop
                    exit 1
                    fi
                    ischanged=1
                fi
            fi
        fi
        # If an OS X has access over afp, this will remove the annoying files it creates.
        if echo "$FILE" | egrep -q "AppleDouble" || echo "$FILE" | egrep -q "DS_Store"
        then
            if [ -f "$FILE" ]
            then
                rm "$FILE"
            else
                rm -rf "$FILE"
            fi
        fi
        if [ $log_activities == "yes" ]
        then
            # In order to record file-changes in .experms.log only if they are not recorded already, we need to give each entry a random delay between 0 - 3.9999999 seconds. Otherwise some of them wouldn't see each other :-)
            random1=$(echo $[ 0 + $[ RANDOM % 3 ]])
            random2=$(echo $[ 0 + $[ RANDOM % 9999999 ]])
            sleep "$random1.$random2"
            if ! cat $MY_ROOT/.experms.log | egrep "`date +%a,\ %m/%d/%y\ -\ %H:%M:`" | egrep -q "\"$FILE\" "
            then
                if [ $ischanged -eq 1 ]
                then
                    echo "`date +%a,\ %m/%d/%y\ -\ %H:%M:%S` \""$FILE"\" has been modified."
                fi
            fi
        fi
        ischanged=0
        exit 0
}
    ##=== FUNCTION ====================================================================================================
    ##        NAME: func_prepare
    ## DESCRIPTION: This function checks if the path fits, if yes, it send it to func_action.
    ## PARAMETER 1: File-name
    ##=================================================================================================================
    func_prepare() {
            FILE="$1"
            subdircountprep=0
            # The obligate for-loop.
            for item in "${subdirname[@]}"
            do
                # Does the file fit our criteria of sub-directories?
                if echo "$FILE" | egrep -q "$mondirname${subdirname[$subdircountprep]}"
                # It does.
                then
                    # Do the action.
                    if [ -f "$FILE" ] || ( [ -d "$FILE" ] && echo "$FILE" | egrep -vq "/$" )
                    then
                        func_action "${subdirown[$subdircountprep]}" "${subdirgrp[$subdircountprep]}" "${subdirchmodoktd[$subdircountprep]}" "${subdirchmodoktf[$subdircountprep]}" "${doitreally[$subdircountprep]}" &
                    break
                    fi
                fi
                subdircountprep=$subdircountprep+1
            done
            unset subdircountprep
}
    ##=== FUNCTION =============================================================================================================
    ##        NAME: func_prepare_dir
    ## DESCRIPTION: There's a bug in inotifywait: If a directory with (a) file(s) is created very fast (for example
    ##              from a bittorrent-client), inotifywait will not recognize the file(s). In Experms this is solved as follows:
    ##              Everytime a directory is changed Experms will process all the containing files with a delay of 1 second.
    ## PARAMETER 1: Path from inotifywait
    ##==========================================================================================================================
    func_prepare_dir() {
                sleep 1
                for FILE in "$1"/*
                do
                    # DO IT
                    func_prepare "$FILE" &
                done
                exit 0
}
    # Using fifo to get the PID of inotifywait.
    FIFONAME=/tmp/myfifo.$$
    rm -f $FIFONAME
    mkfifo $FIFONAME
    # The inotifywait-command (NOTE: You can change the parameters here as they fit you. Do NOT change the "--format %w%f". The script wouldn't work without it.
    inotifywait -mr -e attrib -e create -e moved_to --format %w%f $mondirname > $FIFONAME &
    MYPROGRAM_PID=$!
    # Remove an eventually existing old temp-file.
    rm -f /tmp/perms_pid.sfhsfhi
    # Remember the PID of inotifywait.
    echo $MYPROGRAM_PID > /tmp/perms_pid.sfhsfhi
    # And now run!
    cat $FIFONAME | while read FILERAW
    do
        checkforterm
        #Prepare it
        func_prepare "$FILERAW" &
        # Necessary because of a bug in inotifywait
        if [ -d "$FILERAW" ]
        then
            # If it's a directory, send it through "func_prepare_dir()". I didn't used "if [ -d "$FILERAW" ]" because inotifywait will send a directory with an ending "/" and without. So it would send it through "func_prepare_dir()" two times.
            if ! echo "$FILERAW" | egrep -q "/$"
            then
                func_prepare_dir "$FILERAW" &
            fi
        fi
    done
    exit 0
}

##=== FUNCTION =============================================================================================================
##        NAME: func_restore
## DESCRIPTION: This function restores all the ownerships and permissions based on the config-file.
##==========================================================================================================================
func_restore() {
        subdircount=0
        for item in "${subdirname[@]}"
        do
            if [ "${doitreally[$subdircount]}" -eq 1 ] || [ "${doitreally[$subdircount]}" -eq 3 ] || [ "${doitreally[$subdircount]}" -eq 5 ] || [ "${doitreally[$subdircount]}" -eq 7 ]
            then
                chown -cR "${subdirown[$subdircount]}":"${subdirgrp[$subdircount]}" "$mondirname${subdirname[$subdircount]}" 1>/dev/null
            fi
            if [ "${doitreally[$subdircount]}" -eq 2 ] || [ "${doitreally[$subdircount]}" -eq 3 ] || [ "${doitreally[$subdircount]}" -eq 6 ] || [ "${doitreally[$subdircount]}" -eq 7 ]
            then
                find "$mondirname${subdirname[$subdircount]}" -type d -exec chmod "${subdirchmodoktd[$subdircount]}" {} +
            fi
            if [ "${doitreally[$subdircount]}" -eq 4 ] || [ "${doitreally[$subdircount]}" -eq 5 ] || [ "${doitreally[$subdircount]}" -eq 6 ] || [ "${doitreally[$subdircount]}" -eq 7 ]
            then
                find "$mondirname${subdirname[$subdircount]}" -type f -exec chmod "${subdirchmodoktf[$subdircount]}" {} +
            fi
            subdircount=$subdircount+1
        done
        unset subdircount
        echo "Ownership and permissions of all files have been restored!"
}

# Check if all needed commands are available.
# Taken from http://wiki.bash-hackers.org/scripting/style
my_needed_commands="inotifywait grep ps"
missing_counter=0
for needed_command in $my_needed_commands; do
  if ! hash "$needed_command" >/dev/null 2>&1; then
    printf "Command not found: %s\n" "$needed_command" >&2
    ((missing_counter++))
  fi
done
if ((missing_counter > 0)); then
  printf "Minimum %d commands are missing, aborting\n" "$missing_counter" >&2
  exit 1
fi

MY_PATH=$(readlink -f $0)
MY_ROOT=$(dirname $MY_PATH)
source "$MY_ROOT/check-config.sh"
# Source the daemon-functions.sh for daemonizing.
# AUTHOR: Apokalyptik (http://blog.apokalyptik.com/2008/05/09/as-close-to-a-real-daemon-as-bash-scripts-get/)
source "$MY_ROOT/daemon-functions.sh"

